name: Deploy infrastructure

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Set Azure Credentials
        run: |
          echo "ARM_CLIENT_ID=${{ secrets.AZURE_CLIENT_ID }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=${{ secrets.AZURE_CLIENT_SECRET }}" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=${{ secrets.AZURE_TENANT_ID }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID }}" >> $GITHUB_ENV

      - name: Set AWS Credentials
        run: |
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV

      - name: Terraform Init
        working-directory: terraform/
        run: terraform init

      - name: Terraform Apply
        working-directory: terraform/
        run: terraform apply -auto-approve -var="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" -var="tenant_id=${{ secrets.AZURE_TENANT_ID }}" -var="client_secret=${{ secrets.AZURE_CLIENT_SECRET }}" -var="client_id=${{ secrets.AZURE_CLIENT_ID }}"

      - name: Get Terraform Outputs
        id: tf_outputs
        working-directory: terraform/
        run: |
          echo "aks_cluster_names<<EOF" >> $GITHUB_OUTPUT
          terraform output -json aks_cluster_names >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "acr_name=$(terraform output -raw acr_name)" >> $GITHUB_OUTPUT
          echo "acr_admin_username=$(terraform output -raw acr_admin_username)" >> $GITHUB_OUTPUT
          echo "acr_admin_password=$(terraform output -raw acr_admin_password)" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT
          echo "resource_group_name=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: >-
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }
          auth-type: SERVICE_PRINCIPAL

      - name: Install GitHub CLI
        run: sudo apt-get install gh -y

      - name: Authenticate with GitHub CLI
        run: echo "${{ secrets.GH_PAT }}" | gh auth login --with-token

      - name: Set Organization Secrets for multiple repositories
        run: |
          gh secret set ACR_NAME --org microservices-final-project -b "${{ steps.tf_outputs.outputs.acr_name }}" --visibility "all"    
          gh secret set ACR_USERNAME --org microservices-final-project -b "${{ steps.tf_outputs.outputs.acr_admin_username }}" --visibility "all" 
          gh secret set ACR_PASSWORD --org microservices-final-project -b "${{ steps.tf_outputs.outputs.acr_admin_password }}" --visibility "all"       
          gh secret set RESOURCE_GROUP --org microservices-final-project -b "${{ steps.tf_outputs.outputs.resource_group_name }}" --visibility "all"

      - name: Trigger workflows for multiple branches and wait for completion
        run: |
          repos=("service-discovery" "cloud-config" "api-gateway" "proxy-client" "order-service" "payment-service" "product-service" "shipping-service" "user-service" "favourite-service")
          branches=("main" "stage" "develop")
          declare -A run_ids

          for branch in "${branches[@]}"; do
            echo "ðŸ” Processing branch: $branch"
            # Step 1: Trigger workflows and collect run IDs
            for repo in "${repos[@]}"; do
              echo "ðŸš€ Triggering build.yml in $repo on branch $branch..."
              gh workflow run build.yml \
                --ref "$branch" \
                --repo microservices-final-project/$repo

              # Small delay to allow the run to register
              sleep 5

              # Get the latest run ID for build.yml on the current branch
              run_id=$(gh run list \
                --repo microservices-final-project/$repo \
                --workflow=build.yml \
                --branch="$branch" \
                --limit 1 \
                --json databaseId \
                --jq '.[0].databaseId')

              if [[ -n "$run_id" ]]; then
                run_ids["$repo-$branch"]=$run_id
                echo "âœ… $repo [$branch] run ID: $run_id"
              else
                echo "âŒ Could not get run ID for $repo on branch $branch"
              fi
            done
          done

          echo ""
          echo "â³ Waiting for all workflows to complete..."
          all_done=false

          # Step 2: Poll until all runs are completed
          while [ "$all_done" == "false" ]; do
            all_done=true
            for key in "${!run_ids[@]}"; do
              repo=${key%-*}
              branch=${key#*-}
              run_id=${run_ids[$key]}

              status=$(gh run view "$run_id" \
                --repo microservices-final-project/$repo \
                --json status,conclusion \
                --jq '.status')

              if [[ "$status" != "completed" ]]; then
                echo "â±ï¸  $repo [$branch] is still running..."
                all_done=false
              else
                conclusion=$(gh run view "$run_id" \
                  --repo microservices-final-project/$repo \
                  --json status,conclusion \
                  --jq '.conclusion')
                echo "âœ… $repo [$branch] finished with status: $conclusion"
              fi
            done

            if [ "$all_done" == "false" ]; then
              echo "ðŸ” Waiting 15s before next check..."
              sleep 15
            fi
          done

          echo "ðŸŽ‰ All workflows completed on all branches."

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "latest"

      - name: Add ConfigMap and Deploy Zipkin, Service Discovery, and Cloud Config to all clusters
        run: |
          export ACR_NAME=${{ steps.tf_outputs.outputs.acr_name }}
          echo '${{ steps.tf_outputs.outputs.aks_cluster_names }}' > clusters.json

          for cluster in $(jq -r 'keys[]' clusters.json); do
            cluster_name=$(jq -r --arg c "$cluster" '.[$c]' clusters.json)
            echo "ðŸ”§ Switching context to cluster: $cluster_name (Environment: $cluster)"

            az aks get-credentials \
              --resource-group ${{ steps.tf_outputs.outputs.resource_group_name }} \
              --name "$cluster_name" \
              --overwrite-existing

            echo "ðŸš€ Applying base services to cluster: $cluster_name"

            # Exportar ENVIRONMENT para los manifiestos
            export ENVIRONMENT="$cluster"

            for file in configmap.yaml zipkin.yaml service-discovery.yaml cloud-config.yaml; do
              envsubst < ./k8s/base/$file | kubectl apply -f -
            done

            echo "â³ Esperando 60 segundos para que los servicios estÃ©n listos en $cluster_name..."
            sleep 60
          done

      - name: Deploy Remaining Services to all clusters
        run: |
          export ACR_NAME=${{ steps.tf_outputs.outputs.acr_name }}
          echo '${{ steps.tf_outputs.outputs.aks_cluster_names }}' > clusters.json

          for cluster in $(jq -r 'keys[]' clusters.json); do
            cluster_name=$(jq -r --arg c "$cluster" '.[$c]' clusters.json)
            echo "ðŸ”§ Switching context to cluster: $cluster_name (Environment: $cluster)"

            az aks get-credentials \
              --resource-group ${{ steps.tf_outputs.outputs.resource_group_name }} \
              --name "$cluster_name" \
              --overwrite-existing

            echo "ðŸš€ Applying remaining services to cluster: $cluster_name"

            # Exportar ENVIRONMENT para los manifiestos
            export ENVIRONMENT="$cluster"

            for file in ./k8s/base/*.yaml; do
              if [[ "$file" != *"configmap.yaml" && "$file" != *"zipkin.yaml" && "$file" != *"service-discovery.yaml" && "$file" != *"cloud-config.yaml" ]]; then
                envsubst < "$file" | kubectl apply -f -
              fi
            done
          done