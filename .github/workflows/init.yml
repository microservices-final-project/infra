name: Deploy infrastructure

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Set Azure Credentials
        run: |
          echo "ARM_CLIENT_ID=${{ secrets.AZURE_CLIENT_ID }}" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=${{ secrets.AZURE_CLIENT_SECRET }}" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=${{ secrets.AZURE_TENANT_ID }}" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=${{ secrets.AZURE_SUBSCRIPTION_ID }}" >> $GITHUB_ENV

      - name: Set AWS Credentials
        run: |
          echo "AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> $GITHUB_ENV

      - name: Terraform Init
        working-directory: terraform/
        run: terraform init

      - name: Terraform Apply
        working-directory: terraform/
        run: terraform apply -auto-approve -var="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" -var="tenant_id=${{ secrets.AZURE_TENANT_ID }}" -var="client_secret=${{ secrets.AZURE_CLIENT_SECRET }}" -var="client_id=${{ secrets.AZURE_CLIENT_ID }}"

      - name: Get Terraform Outputs
        id: tf_outputs
        working-directory: terraform/
        run: |
          CLUSTER_NAMES=$(terraform output -json aks_cluster_names)
          echo "cluster_names<<EOF" >> $GITHUB_OUTPUT
          echo "$CLUSTER_NAMES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Debug: mostrar el JSON para verificar
          echo "üîç Cluster names JSON:"
          echo "$CLUSTER_NAMES"

          # Validar que el JSON es v√°lido
          if ! echo "$CLUSTER_NAMES" | jq empty; then
            echo "‚ùå Error: JSON inv√°lido en cluster_names"
            exit 1
          fi

          echo "acr_name=$(terraform output -raw acr_name)" >> $GITHUB_OUTPUT
          echo "acr_admin_username=$(terraform output -raw acr_admin_username)" >> $GITHUB_OUTPUT
          echo "acr_admin_password=$(terraform output -raw acr_admin_password)" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT
          echo "resource_group_name=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: >-
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
            }
          auth-type: SERVICE_PRINCIPAL

      - name: Install GitHub CLI
        run: sudo apt-get install gh -y

      - name: Authenticate with GitHub CLI
        run: echo "${{ secrets.GH_PAT }}" | gh auth login --with-token

      - name: Set Organization Secrets for multiple repositories
        run: |
          gh secret set ACR_NAME --org microservices-final-project -b "${{ steps.tf_outputs.outputs.acr_name }}" --visibility "all"    
          gh secret set ACR_USERNAME --org microservices-final-project -b "${{ steps.tf_outputs.outputs.acr_admin_username }}" --visibility "all" 
          gh secret set ACR_PASSWORD --org microservices-final-project -b "${{ steps.tf_outputs.outputs.acr_admin_password }}" --visibility "all"       
          gh secret set RESOURCE_GROUP --org microservices-final-project -b "${{ steps.tf_outputs.outputs.resource_group_name }}" --visibility "all"

      # - name: Trigger workflows for multiple branches and wait for completion
      #   run: |
      #     repos=("service-discovery" "cloud-config" "api-gateway" "proxy-client" "order-service" "payment-service" "product-service" "shipping-service" "user-service" "favourite-service")
      #     branches=("main" "stage" "develop")
      #     declare -A run_ids

      #     for branch in "${branches[@]}"; do
      #       echo "üîÅ Processing branch: $branch"
      #       # Step 1: Trigger workflows and collect run IDs
      #       for repo in "${repos[@]}"; do
      #         echo "üöÄ Triggering build.yml in $repo on branch $branch..."
      #         gh workflow run build.yml \
      #           --ref "$branch" \
      #           --repo microservices-final-project/$repo

      #         # Small delay to allow the run to register
      #         sleep 5

      #         # Get the latest run ID for build.yml on the current branch
      #         run_id=$(gh run list \
      #           --repo microservices-final-project/$repo \
      #           --workflow=build.yml \
      #           --branch="$branch" \
      #           --limit 1 \
      #           --json databaseId \
      #           --jq '.[0].databaseId')

      #         if [[ -n "$run_id" ]]; then
      #           run_ids["$repo-$branch"]=$run_id
      #           echo "‚úÖ $repo [$branch] run ID: $run_id"
      #         else
      #           echo "‚ùå Could not get run ID for $repo on branch $branch"
      #         fi
      #       done
      #     done

      #     echo ""
      #     echo "‚è≥ Waiting for all workflows to complete..."
      #     all_done=false

      #     # Step 2: Poll until all runs are completed
      #     while [ "$all_done" == "false" ]; do
      #       all_done=true
      #       for key in "${!run_ids[@]}"; do
      #         repo=${key%-*}
      #         branch=${key#*-}
      #         run_id=${run_ids[$key]}

      #         status=$(gh run view "$run_id" \
      #           --repo microservices-final-project/$repo \
      #           --json status,conclusion \
      #           --jq '.status')

      #         if [[ "$status" != "completed" ]]; then
      #           echo "‚è±Ô∏è  $repo [$branch] is still running..."
      #           all_done=false
      #         else
      #           conclusion=$(gh run view "$run_id" \
      #             --repo microservices-final-project/$repo \
      #             --json status,conclusion \
      #             --jq '.conclusion')
      #           echo "‚úÖ $repo [$branch] finished with status: $conclusion"
      #         fi
      #       done

      #       if [ "$all_done" == "false" ]; then
      #         echo "üîÅ Waiting 15s before next check..."
      #         sleep 15
      #       fi
      #     done

      #     echo "üéâ All workflows completed on all branches."

      - name: Add ConfigMap and Deploy Zipkin, Service Discovery, and Cloud Config to all clusters
        run: |
          export ACR_NAME="${{ steps.tf_outputs.outputs.acr_name }}"

          # Crear clusters.json de forma segura
          echo '${{ steps.tf_outputs.outputs.cluster_names }}' > clusters.json

          # Verificar que el JSON es v√°lido antes de continuar
          echo "üîç Verificando clusters.json:"
          cat clusters.json

          if ! jq empty clusters.json; then
            echo "‚ùå Error: JSON inv√°lido en clusters.json"
            exit 1
          fi

          echo "‚úÖ JSON v√°lido, procediendo con deployment..."

          for cluster in $(jq -r 'keys[]' clusters.json); do
            cluster_name=$(jq -r --arg c "$cluster" '.[$c]' clusters.json)
            echo "üîß Switching context to cluster: $cluster_name (Environment: $cluster)"

            az aks get-credentials \
              --resource-group "${{ steps.tf_outputs.outputs.resource_group_name }}" \
              --name "$cluster_name" \
              --overwrite-existing

            echo "üöÄ Applying base services to cluster: $cluster_name"

            export ENVIRONMENT="$cluster"

            # Verificar que los archivos existen antes de aplicarlos
            for file in configmap.yaml zipkin.yaml service-discovery.yaml cloud-config.yaml; do
              if [[ -f "./k8s/base/$file" ]]; then
                echo "üìÑ Applying $file..."
                envsubst < "./k8s/base/$file" | kubectl apply -f -
              else
                echo "‚ö†Ô∏è  Warning: ./k8s/base/$file not found, skipping..."
              fi
            done

            echo "‚è≥ Esperando 60 segundos para que los servicios est√©n listos en $cluster_name..."
            sleep 60
          done

      - name: Deploy Remaining Services to all clusters
        run: |
          export ACR_NAME="${{ steps.tf_outputs.outputs.acr_name }}"

          # Usar el mismo clusters.json del paso anterior
          if [[ ! -f clusters.json ]]; then
            echo '${{ steps.tf_outputs.outputs.cluster_names }}' > clusters.json
          fi

          for cluster in $(jq -r 'keys[]' clusters.json); do
            cluster_name=$(jq -r --arg c "$cluster" '.[$c]' clusters.json)
            echo "üîß Switching context to cluster: $cluster_name (Environment: $cluster)"

            az aks get-credentials \
              --resource-group "${{ steps.tf_outputs.outputs.resource_group_name }}" \
              --name "$cluster_name" \
              --overwrite-existing

            echo "üöÄ Applying remaining services to cluster: $cluster_name"

            export ENVIRONMENT="$cluster"

            # Verificar que el directorio existe
            if [[ -d "./k8s/base/" ]]; then
              for file in ./k8s/base/*.yaml; do
                # Verificar que el archivo existe (evitar expansi√≥n fallida)
                if [[ -f "$file" ]]; then
                  base_file=$(basename "$file")
                  if [[ "$base_file" != "configmap.yaml" && "$base_file" != "zipkin.yaml" && "$base_file" != "service-discovery.yaml" && "$base_file" != "cloud-config.yaml" ]]; then
                    echo "üìÑ Applying $base_file..."
                    envsubst < "$file" | kubectl apply -f -
                  fi
                fi
              done
            else
              echo "‚ö†Ô∏è  Warning: ./k8s/base/ directory not found"
            fi
          done
